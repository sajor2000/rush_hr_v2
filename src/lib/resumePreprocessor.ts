// Resume preprocessing to optimize token usage
export function preprocessResume(resumeText: string): string {
  // Preserve original formatting better
  // Only collapse multiple spaces, keep single line breaks
  let processed = resumeText
    .replace(/[ \t]{2,}/g, ' ')  // Replace 2+ spaces/tabs with single space
    .replace(/\n{3,}/g, '\n\n')  // Replace 3+ newlines with double newline
    .trim();
  
  // Remove common boilerplate phrases
  const boilerplatePatterns = [
    /References available upon request/gi,
    /An equal opportunity employer/gi,
    /Page \d+ of \d+/gi,
    /Printed on .+/gi,
    /Generated by .+/gi,
    /Resume - \d+ pages?/gi,
  ];
  
  boilerplatePatterns.forEach(pattern => {
    processed = processed.replace(pattern, '');
  });
  
  // Normalize common variations
  processed = processed
    .replace(/\b(e-mail|e mail)\b/gi, 'email')
    .replace(/\b(Ph\.D\.|PhD|Ph\.D)\b/gi, 'PhD')
    .replace(/\b(B\.S\.|BS|B\.Sc\.)\b/gi, 'BS')
    .replace(/\b(M\.S\.|MS|M\.Sc\.)\b/gi, 'MS')
    .replace(/\b(Sr\.|Senior)\b/gi, 'Senior')
    .replace(/\b(Jr\.|Junior)\b/gi, 'Junior');
  
  // Extract and structure key sections
  const sections = extractSections(processed);
  
  // Rebuild with structured format for better parsing
  return buildStructuredResume(sections, resumeText);
}

interface ResumeSections {
  contact?: string;
  summary?: string;
  experience?: string;
  education?: string;
  skills?: string;
  certifications?: string;
  other?: string;
}

function extractSections(text: string): ResumeSections {
  const sections: ResumeSections = {};
  
  // Common section headers - very flexible matching
  const sectionPatterns: { [key: string]: RegExp } = {
    contact: /^\s*(contact|personal\s+information|info|name|phone|email|address)\s*[:.-]?\s*$/im,
    summary: /^\s*(summary|objective|profile|professional\s+summary|career\s+objective|about\s+me|overview)\s*[:.-]?\s*$/im,
    experience: /^\s*(experience|work\s+experience|professional\s+experience|employment|work\s+history|career\s+history|employment\s+history|positions\s+held|work\s+background)\s*[:.-]?\s*$/im,
    education: /^\s*(education|academic|qualifications|degrees|schooling|training|academic\s+background)\s*[:.-]?\s*$/im,
    skills: /^\s*(skills|technical\s+skills|core\s+competencies|expertise|technologies|proficiencies|competencies|abilities)\s*[:.-]?\s*$/im,
    certifications: /^\s*(certifications?|licenses?|credentials?|certificates?|professional\s+development)\s*[:.-]?\s*$/im,
  };
  
  // Split text into lines for processing
  const lines = text.split(/\n/);
  let currentSection = 'other';
  const sectionContent: { [key: string]: string[] } = {
    other: []
  };
  
  // Debug logging in development
  if (process.env.NODE_ENV === 'development') {
    console.log('Resume preprocessing - total lines:', lines.length);
    console.log('First 5 lines:', lines.slice(0, 5));
  }
  
  lines.forEach(line => {
    const trimmedLine = line.trim();
    
    // Check if this line is a section header
    let foundSection = false;
    
    // Also check for all-caps versions and with/without colons
    const lineVariations = [
      trimmedLine,
      trimmedLine.toUpperCase(),
      trimmedLine.replace(/[:.-]\s*$/, ''),  // Remove trailing punctuation
    ];
    
    for (const lineVar of lineVariations) {
      for (const [section, pattern] of Object.entries(sectionPatterns)) {
        if (pattern.test(lineVar)) {
          currentSection = section;
          if (!sectionContent[section]) {
            sectionContent[section] = [];
          }
          foundSection = true;
          break;
        }
      }
      if (foundSection) break;
    }
    
    // Add content to current section if not a header
    if (!foundSection && trimmedLine) {
      if (!sectionContent[currentSection]) {
        sectionContent[currentSection] = [];
      }
      sectionContent[currentSection].push(trimmedLine);
    }
  });
  
  // Convert arrays to strings
  for (const [key, content] of Object.entries(sectionContent)) {
    if (content.length > 0) {
      sections[key as keyof ResumeSections] = content.join(' ');
    }
  }
  
  return sections;
}

function buildStructuredResume(sections: ResumeSections, originalText: string): string {
  const parts: string[] = [];
  
  // Debug what sections were found
  if (process.env.NODE_ENV === 'development') {
    const foundSections = Object.keys(sections).filter(key => sections[key as keyof ResumeSections]);
    console.log('Sections found:', foundSections);
    console.log('Section lengths:', Object.entries(sections).map(([key, val]) => `${key}: ${val?.length || 0} chars`));
    
    // Log if very few sections were detected
    if (foundSections.length <= 2) {
      console.warn('Warning: Only', foundSections.length, 'sections detected. Section detection may have failed.');
    }
  }
  
  if (sections.contact) {
    parts.push(`CONTACT: ${sections.contact}`);
  }
  
  if (sections.summary) {
    parts.push(`SUMMARY: ${sections.summary}`);
  }
  
  if (sections.experience) {
    parts.push(`EXPERIENCE: ${sections.experience}`);
  }
  
  if (sections.education) {
    parts.push(`EDUCATION: ${sections.education}`);
  }
  
  if (sections.skills) {
    parts.push(`SKILLS: ${sections.skills}`);
  }
  
  if (sections.certifications) {
    parts.push(`CERTIFICATIONS: ${sections.certifications}`);
  }
  
  if (sections.other) {
    parts.push(`ADDITIONAL: ${sections.other}`);
  }
  
  // If very little was extracted, return original text
  const extractedLength = parts.join('').length;
  const structuredResult = parts.join('\n\n');
  
  if (process.env.NODE_ENV === 'development') {
    console.log('Extraction summary:', {
      originalLength: originalText.length,
      extractedLength,
      extractionRatio: (extractedLength / originalText.length * 100).toFixed(1) + '%'
    });
  }
  
  // If extraction failed (less than 30% of original), return original
  if (extractedLength < originalText.length * 0.3) {
    if (process.env.NODE_ENV === 'development') {
      console.warn('Preprocessing extracted too little content, returning original text');
    }
    return originalText;  // Return original instead of poorly extracted version
  }
  
  return structuredResult;
}

// Estimate token count (rough approximation)
export function estimateTokens(text: string): number {
  // Rough estimate: 1 token â‰ˆ 4 characters
  return Math.ceil(text.length / 4);
}

// Check if resumes are similar enough to use cached result
export function areResumesSimilar(resume1: string, resume2: string): boolean {
  // Normalize for comparison
  const normalize = (text: string) => text.toLowerCase().replace(/\s+/g, ' ').trim();
  const norm1 = normalize(resume1);
  const norm2 = normalize(resume2);
  
  // Quick length check
  if (Math.abs(norm1.length - norm2.length) > norm1.length * 0.2) {
    return false;
  }
  
  // Extract key identifiers
  const extractKey = (text: string) => {
    const emailMatch = text.match(/[\w.-]+@[\w.-]+\.\w+/);
    const phoneMatch = text.match(/\d{3}[-.\s]?\d{3}[-.\s]?\d{4}/);
    return `${emailMatch?.[0] || ''}|${phoneMatch?.[0] || ''}`;
  };
  
  return extractKey(norm1) === extractKey(norm2);
}