// Resume preprocessing to optimize token usage
export function preprocessResume(resumeText: string): string {
  // Remove excessive horizontal whitespace but preserve line breaks
  let processed = resumeText.replace(/[ \t]+/g, ' ').trim();
  
  // Remove common boilerplate phrases
  const boilerplatePatterns = [
    /References available upon request/gi,
    /An equal opportunity employer/gi,
    /Page \d+ of \d+/gi,
    /Printed on .+/gi,
    /Generated by .+/gi,
    /Resume - \d+ pages?/gi,
  ];
  
  boilerplatePatterns.forEach(pattern => {
    processed = processed.replace(pattern, '');
  });
  
  // Normalize common variations
  processed = processed
    .replace(/\b(e-mail|e mail)\b/gi, 'email')
    .replace(/\b(Ph\.D\.|PhD|Ph\.D)\b/gi, 'PhD')
    .replace(/\b(B\.S\.|BS|B\.Sc\.)\b/gi, 'BS')
    .replace(/\b(M\.S\.|MS|M\.Sc\.)\b/gi, 'MS')
    .replace(/\b(Sr\.|Senior)\b/gi, 'Senior')
    .replace(/\b(Jr\.|Junior)\b/gi, 'Junior');
  
  // Extract and structure key sections
  const sections = extractSections(processed);
  
  // Rebuild with structured format for better parsing
  return buildStructuredResume(sections);
}

interface ResumeSections {
  contact?: string;
  summary?: string;
  experience?: string;
  education?: string;
  skills?: string;
  certifications?: string;
  other?: string;
}

function extractSections(text: string): ResumeSections {
  const sections: ResumeSections = {};
  
  // Common section headers - more flexible matching
  const sectionPatterns: { [key: string]: RegExp } = {
    contact: /^(contact|personal information|info)/im,
    summary: /^(summary|objective|profile|professional summary|career objective)/im,
    experience: /^(experience|work experience|professional experience|employment|work history|career history|EXPERIENCE)/im,
    education: /^(education|academic|qualifications|degrees|EDUCATION)/im,
    skills: /^(skills|technical skills|core competencies|expertise|technologies|SKILLS)/im,
    certifications: /^(certifications?|licenses?|credentials?)/im,
  };
  
  // Split text into lines for processing
  const lines = text.split(/\n/);
  let currentSection = 'other';
  const sectionContent: { [key: string]: string[] } = {
    other: []
  };
  
  // Debug logging in development
  if (process.env.NODE_ENV === 'development') {
    console.log('Resume preprocessing - total lines:', lines.length);
    console.log('First 5 lines:', lines.slice(0, 5));
  }
  
  lines.forEach(line => {
    const trimmedLine = line.trim();
    
    // Check if this line is a section header
    let foundSection = false;
    for (const [section, pattern] of Object.entries(sectionPatterns)) {
      if (pattern.test(trimmedLine)) {
        currentSection = section;
        if (!sectionContent[section]) {
          sectionContent[section] = [];
        }
        foundSection = true;
        break;
      }
    }
    
    // Add content to current section if not a header
    if (!foundSection && trimmedLine) {
      if (!sectionContent[currentSection]) {
        sectionContent[currentSection] = [];
      }
      sectionContent[currentSection].push(trimmedLine);
    }
  });
  
  // Convert arrays to strings
  for (const [key, content] of Object.entries(sectionContent)) {
    if (content.length > 0) {
      sections[key as keyof ResumeSections] = content.join(' ');
    }
  }
  
  return sections;
}

function buildStructuredResume(sections: ResumeSections): string {
  const parts: string[] = [];
  
  // Debug what sections were found
  if (process.env.NODE_ENV === 'development') {
    console.log('Sections found:', Object.keys(sections).filter(key => sections[key as keyof ResumeSections]));
    console.log('Section lengths:', Object.entries(sections).map(([key, val]) => `${key}: ${val?.length || 0} chars`));
  }
  
  if (sections.contact) {
    parts.push(`CONTACT: ${sections.contact}`);
  }
  
  if (sections.summary) {
    parts.push(`SUMMARY: ${sections.summary}`);
  }
  
  if (sections.experience) {
    parts.push(`EXPERIENCE: ${sections.experience}`);
  }
  
  if (sections.education) {
    parts.push(`EDUCATION: ${sections.education}`);
  }
  
  if (sections.skills) {
    parts.push(`SKILLS: ${sections.skills}`);
  }
  
  if (sections.certifications) {
    parts.push(`CERTIFICATIONS: ${sections.certifications}`);
  }
  
  if (sections.other) {
    parts.push(`ADDITIONAL: ${sections.other}`);
  }
  
  // If very little was extracted, return original text with warning
  const extractedLength = parts.join('').length;
  if (extractedLength < 200 && process.env.NODE_ENV === 'development') {
    console.warn('Very little content extracted from resume preprocessing, might affect evaluation');
  }
  
  return parts.join('\n\n');
}

// Estimate token count (rough approximation)
export function estimateTokens(text: string): number {
  // Rough estimate: 1 token â‰ˆ 4 characters
  return Math.ceil(text.length / 4);
}

// Check if resumes are similar enough to use cached result
export function areResumesSimilar(resume1: string, resume2: string): boolean {
  // Normalize for comparison
  const normalize = (text: string) => text.toLowerCase().replace(/\s+/g, ' ').trim();
  const norm1 = normalize(resume1);
  const norm2 = normalize(resume2);
  
  // Quick length check
  if (Math.abs(norm1.length - norm2.length) > norm1.length * 0.2) {
    return false;
  }
  
  // Extract key identifiers
  const extractKey = (text: string) => {
    const emailMatch = text.match(/[\w.-]+@[\w.-]+\.\w+/);
    const phoneMatch = text.match(/\d{3}[-.\s]?\d{3}[-.\s]?\d{4}/);
    return `${emailMatch?.[0] || ''}|${phoneMatch?.[0] || ''}`;
  };
  
  return extractKey(norm1) === extractKey(norm2);
}